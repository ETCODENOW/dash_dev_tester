"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KApp = void 0;
const express_1 = __importDefault(require("express"));
const cors_1 = __importDefault(require("cors"));
const axios_1 = __importDefault(require("axios"));
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const path_1 = __importDefault(require("path"));
const date_fns_1 = require("date-fns");
const event_1 = require("./event");
const logger_1 = require("./logger");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
const middleware = __importStar(require("./middleware"));
const errors = __importStar(require("./errors"));
const api = __importStar(require("./api"));
/**
 * Kustomer App
 */
class KApp {
    options;
    /**
     * triggered when your app is installed
     * @param userId user that installed the app
     * @param orgId org that the app was installed in
     */
    onInstall;
    /**
     * triggered when your app is enabled
     * @param userId user that enabled the app
     * @param orgId org that the app was enabled in
     */
    onEnable;
    /**
     * triggered when your app is disabled
     * @param userId user that disabled the app
     * @param orgId org that the app was disabled in
     */
    onDisable;
    /**
     * app logger instance that can be used to log to stdout.
     * To view use `set DEBUG=kapp*`
     */
    log;
    /**
     * express app instance
     */
    get app() {
        return this._app;
    }
    _app;
    _server;
    /**
     * the apps manifest that acts as the apps version state
     */
    get manifest() {
        return this._manifest;
    }
    _manifest;
    /**
     * environment base urls
     */
    get baseUrls() {
        return constants_1.ENVS[this.options.env || 'prod'];
    }
    _startedAt;
    _token;
    _commands = {};
    _events = {};
    _hooks = {};
    /**
     * Kustomer App
     */
    constructor(options) {
        this.options = options;
        this.log = this.options.logger || new logger_1.Logger(this.options.app);
        this._token = jsonwebtoken_1.default.sign({
            app: this.options.app,
            version: this.options.version
        }, this.options.clientSecret);
        this._app = (0, express_1.default)();
        this._app.use((0, cors_1.default)({
            exposedHeaders: ['Content-Security-Policy'],
            origin: (_origin, callback) => {
                callback(null, true);
            }
        }));
        this._app.use(express_1.default.json());
        this._app.use(express_1.default.urlencoded({ extended: true }));
        this._manifest = {
            app: this.options.app,
            title: this.options.title,
            clientId: this.options.clientId,
            clientSecret: this.options.clientSecret,
            url: this.options.url,
            roles: [
                ...this.options.roles,
                // settings roles
                'org.user.setting.read',
                'org.admin.setting.write',
                'org.permission.setting.read',
                'org.permission.setting.update',
                'org.user.logs.write'
            ],
            iconUrl: this.options.iconUrl,
            instructions: this.options.instructions,
            version: this.options.version,
            dependencies: this.options.dependencies || [],
            changelog: this.options.changelog || {},
            description: this.options.description,
            appDetails: this.options.appDetails,
            tags: this.options.tags,
            screenshots: this.options.screenshots || [],
            installUrl: this.options.installUrl,
            postInstallMessage: this.options.postInstallMessage,
            default: this.options.default || false,
            system: this.options.system || false,
            visibility: this.options.visibility,
            settings: this.options.settings,
            klasses: [],
            kviews: [],
            actions: [],
            shortcuts: [],
            commands: [],
            i18n: this.options.i18n,
            outboundWebhooks: []
        };
        this._app.get('/', this._onHealth.bind(this));
        this._app.post('/installed', middleware.withAuth(this.options.clientSecret), this._onInstall.bind(this));
        this._app.post('/enabled', middleware.withAuth(this.options.clientSecret), this._onEnable.bind(this));
        this._app.post('/disabled', middleware.withAuth(this.options.clientSecret), this._onDisable.bind(this));
        this._app.post('/commands/:command', middleware.withAuth(this.options.clientSecret), this._onCommand.bind(this));
        this._app.post('/events/:event', middleware.withAuth(this.options.clientSecret), this._onEvent.bind(this));
        this._app.post('/orgs/:org/hooks/:hook', this._onHook.bind(this));
        this._app.use('/assets', express_1.default.static(path_1.default.join(process.cwd(), '/assets')));
    }
    /**
     * start app server and publish new app version if necessary
     * @param options properties used to configure app server startup
     */
    start(options = {}) {
        const { port = 80, publish = true, serverOptions } = options;
        this._app.use(middleware.onError());
        this._server = http_1.default.createServer(this._app);
        if (serverOptions?.key && serverOptions?.cert) {
            const { key, cert } = serverOptions;
            this._server = https_1.default.createServer({ key, cert }, this._app);
        }
        return new Promise((resolve, reject) => {
            this._server?.listen(port, async () => {
                try {
                    if (publish) {
                        await axios_1.default.post(`${this.baseUrls.gateway}/v1/apps/${this.options.app}/versions`, this._manifest, {
                            headers: {
                                'x-kustomer-app-client-id': this.options.clientId,
                                'x-kustomer-app-token': this._token
                            }
                        });
                    }
                }
                catch (err) {
                    await this.stop();
                    if (axios_1.default.isAxiosError(err)) {
                        if (err.response?.data) {
                            return reject(err.response.data);
                        }
                        return reject(err.message);
                    }
                    return reject(err);
                }
                this._startedAt = new Date();
                this.log.info(`started on port ${port}`);
                resolve();
            });
        });
    }
    /**
     * stop app server
     */
    stop() {
        return new Promise((resolve, reject) => {
            if (!this._server?.listening) {
                return resolve();
            }
            this._server.close((err) => {
                if (err) {
                    return reject(err);
                }
                resolve();
            });
        });
    }
    /**
     * in an org, make a request
     * @param identifier the name, id, or token of the org
     */
    org(identifier) {
        let token;
        let orgIdOrName;
        const decoded = jsonwebtoken_1.default.decode(identifier);
        if (decoded) {
            if (!decoded.org) {
                throw new Error('invalid token, org not found');
            }
            orgIdOrName = decoded.org;
            token = identifier;
        }
        else {
            orgIdOrName = identifier;
        }
        return new api.Orgs(this._token, orgIdOrName, {
            ...this.options,
            token
        });
    }
    onCommand(name, options, callback) {
        const fullName = (0, utils_1.namespace)(name, this.options);
        const cb = typeof options === 'function' ? options : callback;
        if (this._commands[name]) {
            throw new Error('duplicate command name');
        }
        if (typeof options === 'object' && options.action) {
            if (this._manifest.actions.some((a) => a.name === fullName)) {
                throw new Error('duplicate action name');
            }
            if (!options.description) {
                throw new Error('actions must have a description');
            }
            this._manifest.actions.push({
                type: 'internal_api',
                name: fullName,
                description: options.description,
                inputTemplate: {
                    orgId: '/#_env.orgId',
                    url: `https://commands:8443/v1/commands/${this.options.app}.app.${fullName}/run`,
                    method: 'POST',
                    data: {
                        args: '/#args',
                        body: '/#body',
                        headers: '/#headers',
                        urlArgs: '/#urlArgs'
                    }
                },
                outputTemplate: {
                    commandId: '/#body.data.attributes.commandId',
                    args: '/#body.data.attributes.args',
                    url: '/#body.data.attributes.url',
                    requestHeaders: '/#body.data.attributes.requestHeaders',
                    requestBody: '/#body.data.attributes.requestBody',
                    responseBody: '/#body.data.attributes.responseBody',
                    statusCode: '/#body.data.attributes.statusCode',
                    requestError: '/#body.data.attributes.requestError'
                }
            });
        }
        this._manifest.commands.push({
            name: fullName,
            httpMethod: 'post',
            type: 'external-api',
            url: `${this.options.url}/commands/${name}`,
            defaultHeaders: {
                'x-kustomer-app-token': this._token
            }
        });
        this._commands[name] = async (req, res, next) => {
            const orgId = req.get('x-kustomer-org-id');
            const userId = req.get('x-kustomer-user-id');
            try {
                res.send(await cb(orgId, userId, req.body));
            }
            catch (err) {
                next(err);
            }
        };
    }
    /**
     * listen for a hook `[POST] /orgs/:org/hooks/:hook`
     * @param name name of hook (unique)
     * @param callback
     */
    onHook(name, callback) {
        if (this._hooks[name]) {
            throw new Error('duplicate hook name');
        }
        this._hooks[name] = async (req, res, next) => {
            try {
                res.send(await callback(req.params.org, req.query, req.headers, req.body));
            }
            catch (err) {
                next(err);
            }
        };
    }
    /**
     * listen for auth requests
     * `[GET] /auth`
     * @param callback
     */
    onAuth(callback) {
        this._app.get('/auth', callback);
    }
    /**
     * listen for auth redirect requests
     * `[GET] /auth/redirect`
     * @param callback
     */
    onAuthComplete(callback) {
        this._app.get('/auth/redirect', callback);
    }
    /**
     * subscribe to a system event
     * @param resource data type
     * @param action action being performed on data type
     */
    on(resource, action, callback) {
        if (this._events[`${resource}-${action}`]) {
            throw new Error('duplicate event name');
        }
        this._manifest.outboundWebhooks.push({
            name: `${this.options.app}--${resource}-${action}`,
            events: [`kustomer.${resource}.${action}`],
            url: `${this.options.url}/events/${resource}-${action}`,
            headers: [
                {
                    name: 'x-kustomer-app-token',
                    value: this._token
                }
            ]
        });
        this._events[`${resource}-${action}`] = async (req, res, next) => {
            try {
                res.send(await callback(req.body));
            }
            catch (err) {
                next(err);
            }
        };
    }
    /**
     * add a Klass to the app that will be created on install
     * @param name name of the klass (unique)
     * @param options options to create a klass
     */
    useKlass(name, options) {
        const fullName = (0, utils_1.namespace)(name, this.options);
        if (this._manifest.klasses.some((v) => v.name === fullName)) {
            throw new Error('duplicate klass name');
        }
        this._manifest.klasses.push({
            name: fullName,
            ...options
        });
    }
    /**
     * add a KView to the app that will be created on install
     * @param name name of the kview (unique)
     * @param jsxOrPath string representation of what Kustomer will attempt to render. This can be vanilla HTML, JS, JSX,
     * or a relative file path to a view you want to iframe.
     * @param options options to create a kview
     */
    useView(name, jsxOrPath, options) {
        const fullName = (0, utils_1.namespace)(name, this.options);
        let resource = options.resource;
        if (resource === 'kobject' && options.klass) {
            resource = `${resource}.${(0, utils_1.namespace)(options.klass, this.options)}`;
        }
        if (this._manifest.kviews.some((v) => v.name === fullName)) {
            throw new Error('duplicate view name');
        }
        this._manifest.kviews.push({
            meta: {
                icon: options.icon,
                displayName: options.displayName,
                state: options.state
            },
            name: fullName,
            context: options.context,
            resource: options.klass
                ? `${options.resource}.${(0, utils_1.namespace)(options.klass, this.options)}`
                : options.resource,
            template: !options.iframe
                ? jsxOrPath
                : `
        <div>
          <DynamicCard
            src="${this.options.url}/views/${name}"
            context={object.context}
            noPadding
            fillToWidth
          />
        </div>
      `
        });
        if (options.iframe) {
            this._app.use(`/views/${name}`, express_1.default.static(path_1.default.join(process.cwd(), jsxOrPath), {
                maxAge: 3600000,
                setHeaders: (res) => {
                    res.setHeader('Content-Security-Policy', `frame-src * data: blob: ;`);
                }
            }));
        }
    }
    /**
     * add a settings view that will be rendered via iframe
     * `[GET] /views/settings`
     * @param title page title
     * @param description page description
     * @param pathTo path to the build directory that contains your index.html
     */
    useSettings(title, description, pathTo) {
        this._manifest.settingsPageConfig = {
            title,
            description,
            url: `${this.options.url}/views/settings`
        };
        this._app.use('/views/settings', express_1.default.static(path_1.default.join(process.cwd(), pathTo), {
            maxAge: 3600000,
            setHeaders: (res) => {
                res.setHeader('Content-Security-Policy', `frame-src * data: blob: ;`);
            }
        }));
    }
    /**
     * add setup steps that will be rendered via iframe
     * @param pathTo path to the build directory that contains your index.html
     */
    useSetup(pathTo) {
        this._manifest.setupUrl = `${this.options.url}/views/setup`;
        this._app.use('/views/setup', express_1.default.static(path_1.default.join(process.cwd(), pathTo), {
            maxAge: 3600000,
            setHeaders: (res) => {
                res.setHeader('Content-Security-Policy', `frame-src * data: blob: ;`);
            }
        }));
    }
    _onHealth(_req, res, _next) {
        res.send({
            name: this.options.app,
            version: this.options.version,
            uptime: this._startedAt ? (0, date_fns_1.formatDistanceToNow)(this._startedAt) : null,
            startedAt: this._startedAt ? this._startedAt.getTime() : null
        });
    }
    _onInstall(req, res, next) {
        if (!this.onInstall) {
            return res.send();
        }
        const orgId = req.get('x-kustomer-org-id');
        const userId = req.get('x-kustomer-user-id');
        if (!orgId || !userId) {
            return next(new errors.BadRequestError('x-kustomer-org-id and x-kustomer-user-id headers are required'));
        }
        this.onInstall(userId, orgId);
        res.send();
    }
    _onEnable(req, res, next) {
        if (!this.onEnable) {
            return res.send();
        }
        const orgId = req.get('x-kustomer-org-id');
        const userId = req.get('x-kustomer-user-id');
        if (!orgId || !userId) {
            return next(new errors.BadRequestError('x-kustomer-org-id and x-kustomer-user-id headers are required'));
        }
        this.onEnable(userId, orgId);
        res.send();
    }
    _onDisable(req, res, next) {
        if (!this.onDisable) {
            return res.send();
        }
        const orgId = req.get('x-kustomer-org-id');
        const userId = req.get('x-kustomer-user-id');
        if (!orgId || !userId) {
            return next(new errors.BadRequestError('x-kustomer-org-id and x-kustomer-user-id headers are required'));
        }
        this.onDisable(userId, orgId);
        res.send();
    }
    _onCommand(req, res, next) {
        if (!this._commands[req.params.command]) {
            return next(new errors.NotFoundError('command not found'));
        }
        const orgId = req.get('x-kustomer-org-id');
        const userId = req.get('x-kustomer-user-id');
        if (!orgId || !userId) {
            return next(new errors.BadRequestError('x-kustomer-org-id and x-kustomer-user-id headers are required'));
        }
        this._commands[req.params.command](req, res, next);
    }
    _onEvent(req, res, next) {
        if (!this._events[req.params.event]) {
            return next(new errors.NotFoundError('event not found'));
        }
        const valid = event_1.EVENT_SCHEMA.validate({
            id: req.body.id,
            name: req.body.name,
            orgId: req.body.org || req.body.orgId,
            data: req.body.data,
            createdAt: req.body.createdAt
        });
        if (valid.error) {
            return next(new errors.BadRequestError('invalid event payload'));
        }
        req.body = valid.value;
        this._events[req.params.event](req, res, next);
    }
    _onHook(req, res, next) {
        if (!this._hooks[req.params.hook]) {
            return next(new errors.NotFoundError('hook not found'));
        }
        this._hooks[req.params.hook](req, res, next);
    }
}
exports.KApp = KApp;
//# sourceMappingURL=kapp.js.map